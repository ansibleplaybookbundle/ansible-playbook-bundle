# How to create an ansible playbook bundle (APB) using roles from ansible-galaxy

The easiest manner to produce an APB is to start with ansible-container. Ansible-container will give us all the tools we need to link preexisting roles from Galaxy and piece them together to create a substantial application ready to run on OCP or Kubernetes.

```
ansible-container init
```

This produces a directory structure as follows:

```
AnsiblePlaybookBundle/
    ansible/
        container.yml
        main.yml
        ansible.cfg
        requirements.txt
        requirements.yml
        meta.yml
```

The first file to edit is requirements.yml to add the roles necessary to run the application.
ex. requirements.yml:

```
- src: dymurray.etherpad-centos-container
- src: chouseknecht.mariadb-container
```

This gives us the containers we want to link together for our application. We now want to edit container.yml to specify which services will be running and any environment variables needed to configure the container.
ex. container.yml

```
---                                                                                                                                                                                                         [1/712]
- hosts: mariadb
  gather_facts: false
  roles:
    - chouseknecht.mariadb-container

- hosts: etherpad
  gather_facts: true
  roles:
    - dymurray.etherpad-centos-container
[vagrant@cap ~]$ cat screencast/ansible/container.yml 
version: "2"
services:
  etherpad:
    image: centos:7
    ports:
      - "9001:9001"
    expose:
      - 9001
    command: ['/opt/etherpad-lite/bin/run.sh']
    user: etherpad-lite
    depends_on:
      - mariadb
    links:
      - mariadb
    dev_overrides:
     environment:
       - "DEBUG=1"

  mariadb:
    image: centos:7
    ports:
      - "3306:3306"
    expose:
      - 3306
    environment:
      - "MARIADB_DATABASE=etherpadlite"
      - "MARIADB_USERNAME=etherpadlite"
      - "MARIADB_PASSWORD=password"
      - "MARIADB_ROOT_PASSWORD=password"
    entrypoint: ['/usr/bin/entrypoint.sh']
    command: ["/usr/bin/dumb-init", "mysqld"]
    user: mysql

    dev_overrides:
     environment:
       - "DEBUG=1"

registries: {}

```

Now that we have specified our services in container.yml we need to edit main.yml to specify which services will be running which roles. This is fairly straightforward as seen below:
ex. main.yml

```
---
- hosts: mariadb
  gather_facts: false
  roles:
    - chouseknecht.mariadb-container

- hosts: etherpad
  gather_facts: true
  roles:
    - dymurray.etherpad-centos-container
```

We now have all that we need to build a simple APB. We now run

```
ansible-container build
```

This will produce some images locally for us ready to deploy as individual containers. We now want to make our application deployable to OpenShift. To do this we run:

```
ansible-container shipit openshift --local-images
```

The --local-images flag specifies that ansible-container should use images on the local docker daemon (so the containers we just built). This command produces a new file 'shipit-openshift.yml' which really is just a playbook that calls the role generated by the shipit command.

We now have enough to deploy the application to openshift simply by running:

```
ansible-playbook ansible/shipit-openshift.yml
```

# Packaging application as an Ansible Playbook Bundle

From here you may refer to ##LINK_TO_OTHER_DOC HERE## for directory layout structure. But the simplest steps are as follows.

The first step is to create a new directory called 'apb' and a Dockerfile for the entire application so that our file structure changes as so:

```
AnsiblePlaybookBundle/
    Dockerfile
    ansible/
        roles/
        container.yml
        main.yml
        ansible.cfg
        requirements.txt
        requirements.yml
        meta.yml
        shipit-openshift.yml
    apb/
        actions/
            provision.yaml
            deprovision.yaml
```

Until we create provision.yaml and deprovision.yaml under actions, lets first make a Dockerfile for our application which looks like so:
ex. Dockerfile

```
FROM ansibleplaybookbundle/apb-base

MAINTAINER Dylan Murray <dymurray@redhat.com>

ADD ansible /usr/local/ansible
ADD apb/actions /apb/actions
```

We now want to make an almost identical copy to shipit-openshift.yml and use that as provision.yaml but our roles are now located at /usr/local/ansible/roles per our Dockerfile. So provision.yaml looks something like:

```
- name: Deploy AnsiblePlaybookBundle to openshift
  hosts: localhost
  gather_facts: false
  connection: local
  roles:
  - role: /usr/local/ansible/roles/apb-openshift
    playbook_debug: false
```

And since deprovision.yaml is really just deleting the project, it's very simple.

```
- hosts: localhost
  gather_facts: false
  connection: local
  tasks:
  - name: Delete apb project
    command: oc delete project apb
```

We can now build this container by running from the parent directory:

```
docker build -t MyNewApb .
```

And can run the application with:

```
docker run -e "OPENSHIFT_TARGET=<oc_cluster_address>" -e "OPENSHIFT_USER=<oc_user>" -e "OPENSHIFT_PASS=<oc_pass>" <apb_name> $action
```

where $action is either provision or deprovision.
